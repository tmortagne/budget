<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>BudgetCode</web>
<name>BudgetService</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>xwiki:XWiki.ThomasMortagne</creator>
<author>xwiki:XWiki.ThomasMortagne</author>
<customClass></customClass>
<contentAuthor>xwiki:XWiki.ThomasMortagne</contentAuthor>
<creationDate>1303318305000</creationDate>
<date>1303919486000</date>
<contentUpdateDate>1303919486000</contentUpdateDate>
<version>10.1</version>
<title></title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<content>{{groovy}}
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;
import org.mortagne.budget.transaction.Transaction;
import org.mortagne.budget.transaction.io.TransactionReader;
import org.mortagne.budget.transaction.io.TransactionReaderConfiguration;
import org.mortagne.budget.transaction.io.TransactionReaderFactory;
import org.xwiki.model.EntityType;
import org.xwiki.model.reference.DocumentReference;
import org.xwiki.model.reference.EntityReference;
import org.xwiki.query.Query;
import org.xwiki.query.QueryException;
import org.xwiki.query.QueryManager;

import com.xpn.xwiki.XWikiContext;
import com.xpn.xwiki.XWikiException;
import com.xpn.xwiki.doc.XWikiAttachment;
import com.xpn.xwiki.doc.XWikiDocument;
import com.xpn.xwiki.objects.BaseObject;
import com.xpn.xwiki.web.Utils;

class BudgetService
{
    private XWikiContext context;

    private Map&lt;String, Filter&gt; filters;

    public BudgetService(XWikiContext context)
    {
        this.context = context;
    }

    public String getAccountSpace(String account)
    {
        return "Account" + account;
    }

    public DocumentReference getTransactionClassReference()
    {
        return new DocumentReference(this.context.getDatabase(), "BudgetCode", "AccountTransactionClass");
    }

    public Map&lt;String, Filter&gt; getFilters() throws QueryException
    {
        if (this.filters == null) {
            this.filters = new HashMap&lt;String, Filter&gt;();

            QueryManager queryManager = Utils.getComponent(QueryManager.class);

            Query query =
                queryManager
                    .createQuery(
                        "select doc.fullName, filter.pattern, filter.category, filter.internal from Document doc, doc.object(BudgetCode.AccountTransactionFilterClass) as filter",
                        Query.XWQL);

            List&lt;Object[]&gt; filtersDatas = query.execute();

            for (Object[] filterDatas : filtersDatas) {
                this.filters.put((String) filterDatas[0], new Filter((String) filterDatas[1], (String) filterDatas[2],
                    (Integer) filterDatas[3]));
            }
        }

        return this.filters;
    }

    public String getCategory(String description)
    {
        Filter filter = getMatchingFilter(description);

        if (filter != null) {
            return filter.category;
        }

        return null;
    }

    private Filter getMatchingFilter(String description)
    {
        Map&lt;String, Filter&gt; filters;
        try {
            filters = getFilters();
        } catch (QueryException e) {
            return null;
        }

        for (Filter filter : filters.values()) {
            if (Pattern.matches(filter.pattern, description)) {
                return filter;
            }
        }

        return null;
    }

    public DocumentReference getTransactionDocument(String wiki, String account, Transaction transaction)
    {
        return new DocumentReference(wiki, getAccountSpace(account), transaction.getId().replace('/', '-'));
    }

    public void importAttachment(String attachmentFilename, String readerId, String account) throws Exception
    {
        TransactionReaderFactory readerFactory = Utils.getComponent(TransactionReaderFactory.class, readerId);

        XWikiAttachment attachment = this.context.getDoc().getAttachment(attachmentFilename);

        if (attachment == null) {
            throw new Exception("Can't find attachment [" + attachmentFilename + "] in document ["
                + this.context.getDoc() + "]");
        }

        TransactionReaderConfiguration configuration = new TransactionReaderConfiguration();

        TransactionReader reader =
            readerFactory.createTransactionReader(attachment.getContentInputStream(this.context), configuration);

        for (Transaction transaction = reader.next(); transaction != null; transaction = reader.next()) {
            registerTransation(transaction, account, false);
        }
    }

    public DocumentReference getAccountTransactionTemplateReference() throws XWikiException
    {
        return new DocumentReference(this.context.getDatabase(), "BudgetCode", "AccountTransactionClassTemplate");
    }

    public XWikiDocument getAccountTransactionTemplate() throws XWikiException
    {
        return this.context.getWiki().getDocument(getAccountTransactionTemplateReference(), this.context);
    }

    public DocumentReference registerTransation(Transaction transaction, String account, boolean force)
        throws XWikiException
    {
        XWikiDocument document =
            this.context.getWiki().getDocument(
                getTransactionDocument(this.context.getDatabase(), account, transaction), this.context);

        if (force || document.isNew()) {
            XWikiDocument template = getAccountTransactionTemplate();

            if (!template.isNew()) {
                document.readFromTemplate(template.getDocumentReference(), this.context);
                document.setTitle(template.getTitle());
            }

            document.setParentReference(new EntityReference("WebHome", EntityType.DOCUMENT));

            BaseObject xtransaction = document.getXObject(getTransactionClassReference(), true, this.context);

            xtransaction.setStringValue("account", account);
            xtransaction.setStringValue("description", transaction.getDescription());
            xtransaction.setStringValue("type", transaction.getType());
            xtransaction.setDateValue("date", transaction.getDate());
            xtransaction.setDateValue("realdate", transaction.getRealDate() != null ? transaction.getRealDate()
                : transaction.getDate());
            xtransaction.setFloatValue("value", transaction.getValue());
            xtransaction.setIntValue("categoryauto", 1);

            if (transaction.getDescription() != null) {
                Filter filter = getMatchingFilter(transaction.getDescription());
                xtransaction.setStringValue("category", filter.category);
                xtransaction.setIntValue("internal", filter.internal ? 1 : 0);
            } else {
                xtransaction.setIntValue("internal", 0);
            }

            this.context.getWiki().saveDocument(document, this.context);
        }

        return document.getDocumentReference();
    }

    public int applyFilter(String filterId) throws QueryException, XWikiException
    {
        Filter filter = getFilters().get(filterId);

        QueryManager queryManager = Utils.getComponent(QueryManager.class);

        Query query =
            queryManager.createQuery(
                "select doc.space, doc.name, transaction.description"
                    + " from Document doc, doc.object(BudgetCode.AccountTransactionClass) as transaction"
                    + " where doc.name &lt;&gt; 'AccountTransactionClassTemplate'"
                    + " and (transaction.category is null or transaction.category &lt;&gt; :category)"
                    + " and (transaction.categoryauto is null or transaction.categoryauto = 1)", Query.XWQL).bindValue(
                "category", filter.category);

        List&lt;Object[]&gt; transactionsDatas = query.execute();

        int nb = 0;
        Pattern pattern = Pattern.compile(filter.pattern);
        for (Object[] transactionDatas : transactionsDatas) {
            if (!StringUtils.isEmpty((String) transactionDatas[2])
                &amp;&amp; pattern.matcher((String) transactionDatas[2]).matches()) {
                XWikiDocument transactionDocument =
                    this.context.getWiki().getDocument(
                        new DocumentReference(this.context.getDatabase(), (String) transactionDatas[0],
                            (String) transactionDatas[1]), context);

                DocumentReference transactionClassReference = getTransactionClassReference();
                transactionDocument.setStringValue(getTransactionClassReference(), "category", filter.category);
                transactionDocument.setIntValue(transactionClassReference, "internal", filter.internal ? 1 : 0);

                this.context.getWiki().saveDocument(transactionDocument, context);

                ++nb;
            }
        }

        return nb;
    }

    public List&lt;List&lt;Object&gt;&gt; resolveTable(List&lt;Object[]&gt; datas)
    {
        List&lt;List&lt;Object&gt;&gt; table = new ArrayList&lt;List&lt;Object&gt;&gt;();

        List&lt;Object&gt; currentRow = null;
        String previousDate = null;
        Float savedValue = null;
        boolean negatifFound = false;
        for (Object[] data : datas) {
            String date = (String) data[0];
            float value = (Float) data[1];
            if (!date.equals(previousDate)) {
                if (savedValue != null) {
                    table.add(currentRow = Arrays.&lt;Object&gt; asList(previousDate, 0, savedValue));
                    savedValue = null;
                }
                if (negatifFound) {
                    currentRow.set(2, 0);
                }
                negatifFound = false;
            }
            float positiveValue = value;
            if (positiveValue &lt; 0) {
                positiveValue = positiveValue * -1;
                if (savedValue != null) {
                    table.add(currentRow = Arrays.&lt;Object&gt; asList(date, positiveValue, savedValue));
                    savedValue = null;
                    negatifFound = false;
                } else {
                    if (negatifFound) {
                        currentRow.set(2, 0);
                    }
                    table.add(currentRow = Arrays.&lt;Object&gt; asList(date, positiveValue, 0));
                    negatifFound = true;
                }
            } else {
                if (negatifFound) {
                    currentRow.set(2, positiveValue);
                    negatifFound = false;
                } else {
                    savedValue = positiveValue;
                }
            }
            previousDate = date;
        }
        if (savedValue != null) {
            table.add(currentRow = Arrays.&lt;Object&gt; asList(previousDate, 0, savedValue));
        }

        return table;
    }

    public static class Filter
    {
        public String pattern;

        public String category;

        public boolean internal;

        public Filter(String pattern, String category, Integer internal)
        {
            this(pattern, category, internal == Integer.valueOf(1));
        }

        public Filter(String pattern, String category, boolean internal)
        {
            this.pattern = pattern;
            this.category = category;
            this.internal = internal;
        }
    }
}

if (xcontext.get("budgetservice") == null) {
  xcontext.put("budgetservice", new BudgetService(xcontext.context))
}
{{/groovy}}

{{velocity}}
#set($budgetservice = $xcontext.budgetservice)
{{/velocity}}</content></xwikidoc>
